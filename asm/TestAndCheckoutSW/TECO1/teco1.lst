Block I Apollo Guidance Computer (AGC4) assembler version 1.6 for EPROM

First pass: generate symbol table.
Second pass: generate object code.

                          ; TECO1 (file:teco1.asm)
                          ; 
                          ; Version:	1.0
                          ; Author:	John Pultorak
                          ; Date:	9/14/2001
                          ; 
                          ; PURPOSE:
                          ; Test and checkout program for the Block 1 Apollo Guidance Computer.
                          ; Tests basic instructions: TC, CCS, INDEX, XCH, CS, TS, AD, MASK.
                          ; 
                          ; OPERATION:
                          ; Enters an infinite loop at the end of the test. The A register contains 
                          ; the code for the test that failed, or the PASS code if all tests 
                          ; succeeded. See test codes below.
                          ; 
                          ; ERRATA:
                          ; - Written for the AGC4R assembler. The assembler directives and syntax
                          ; differ somewhat from the original AGC assembler.
                          ; - The tests attempt to check all threads, but are not exhaustive.
                          ; 
                          ; SOURCES:
                          ; Information on the Block 1 architecture: instruction set, instruction
                          ; sequences, registers, register transfers, control pulses, memory and 
                          ; memory addressing, I/O assignments, interrupts, and involuntary counters
                          ; was obtained from:
                          ; 
                          ;	A. Hopkins, R. Alonso, and H. Blair-Smith, "Logical Description 
                          ;		for the Apollo Guidance Computer (AGC4)", R-393, 
                          ;		MIT Instrumentation Laboratory, Cambridge, MA, Mar. 1963.
                          ; 
                          ; Supplementary information was obtained from:
                          ; 
                          ;	R. Alonso, J. H. Laning, Jr. and H. Blair-Smith, "Preliminary 
                          ;		MOD 3C Programmer's Manual", E-1077, MIT Instrumentation 
                          ;		Laboratory, Cambridge, MA, Nov. 1961.
                          ; 
                          ;	B. I. Savage and A. Drake, "AGC4 Basic Training Manual, Volume I", 
                          ;		E-2052, MIT Instrumentation Laboratory, Cambridge, 
                          ;		MA, Jan. 1967.
                          ; 
                          ;	E. C. Hall, "MIT's Role in Project Apollo, Volume III, Computer 
                          ;		Subsystem", R-700, MIT Charles Stark Draper Laboratory, 
                          ;		Cambridge, MA, Aug. 1972.
                          ; 
                          ;	A. Hopkins, "Guidance Computer Design, Part VI", source unknown.
                          ; 
                          ;	A. I. Green and J. J. Rocchio, "Keyboard and Display System Program 
                          ;		for AGC (Program Sunrise)", E-1574, MIT Instrumentation 
                          ;		Laboratory, Cambridge, MA, Aug. 1964.
                          ; 
                          ;	E, C. Hall, "Journey to the Moon: The History of the Apollo 
                          ;		Guidance Computer", AIAA, Reston VA, 1996.
                          ; 
                          
                          START          EQU      %00            
                          
                          TCtst          EQU      %01            ; TC check failed
                          CCStst         EQU      %02            ; CCS check failed
                          INDEXtst       EQU      %03            ; INDEX check failed
                          XCHtst         EQU      %04            ; XCH check failed
                          CStst          EQU      %05            ; CS check failed
                          TStst          EQU      %06            ; TS check failed
                          ADtst          EQU      %07            ; AD check failed
                          MASKtst        EQU      %10            ; MASK check failed
                          
                          PASS           EQU      %12345         ; PASSED all checks
                          ; ----------------------------------------------
                          
                                         ORG      EXTENDER       
05777    5777     47777 0                DS       %47777         ; needed for EXTEND
                          
                          OVFCNTR        EQU      %00034         ; overflow counter
                          
                          ; ----------------------------------------------
                          ; ERASEABLE MEMORY -- DATA SEGMENT
                          
                                         ORG      %100           ; start of data area
00100    0100     00000 1 curtest        DS       START          ; current test
00101    0101     00000 1 savQ           DS       %0             
                          
                          ; CCS test
00102    0102     00000 1 CCSk           DS       %0             
                          
                          ; INDEX test
00103    0103     00000 1 INDXval        DS       0              
                          
                          ; XCH test
                          ; pre-set in erasable memory because we don't
                          ; want to use XCH to initialize them prior to testing XCH.
00104    0104     00000 1 XCHkP0         DS       +0             
00105    0105     77777 0 XCHkM0         DS       -0             
00106    0106     52525 1 XCHkalt1       DS       %52525         ; alternating bit pattern 1
00107    0107     25252 0 XCHkalt2       DS       %25252         ; alternating bit pattern 2
                          
                          ; TS test
00110    0110     77777 0 TSk            DS       -0             
                          
                          ; AD test
00111    0111     77777 0 ADk            DS       -0             
                          
                          ; ----------------------------------------------
                          ; ENTRY POINTS
                          
                          ; program (re)start
                                         ORG      GOPROG         
02000    2000 0  1,2030 0                TC       goMAIN         
                          
                          ; interrupt service entry points
                                         ORG      T3RUPT         
02004    2004 5  0,0026 0                TS       ARUPT          
02005    2005 3  0,0001 0                XCH      Q              
02006    2006 5  0,0027 1                TS       QRUPT          
02007    2007 0  1,2717 1                TC       goT3           
                          
                                         ORG      ERRUPT         
02010    2010 5  0,0026 0                TS       ARUPT          
02011    2011 3  0,0001 0                XCH      Q              
02012    2012 5  0,0027 1                TS       QRUPT          
02013    2013 0  1,2717 1                TC       goER           
                          
                                         ORG      DSRUPT         
02014    2014 5  0,0026 0                TS       ARUPT          
02015    2015 3  0,0001 0                XCH      Q              
02016    2016 5  0,0027 1                TS       QRUPT          
02017    2017 0  1,2717 1                TC       goDS           
                          
                                         ORG      KEYRUPT        
02020    2020 5  0,0026 0                TS       ARUPT          
02021    2021 3  0,0001 0                XCH      Q              
02022    2022 5  0,0027 1                TS       QRUPT          
02023    2023 0  1,2717 1                TC       goKEY          
                          
                          
                                         ORG      UPRUPT         
02024    2024 5  0,0026 0                TS       ARUPT          
02025    2025 3  0,0001 0                XCH      Q              
02026    2026 5  0,0027 1                TS       QRUPT          
02027    2027 0  1,2717 1                TC       goUP           
                          
                          ; ----------------------------------------------
                          ; FIXED MEMORY -- SHARED DATA SEGMENT
                          
                          ; ----------------------------------------------
                          ; MAIN PROGRAM
                          
                          goMAIN         EQU      *              
02030    2030 2  0,0000 0                INHINT                  ; disable interrupts
                          
02031    2031 0  1,2047 0                TCR      begin          
                          
                          ; Test basic instructions.
02032    2032 0  1,2054 1                TCR      chkTC          
02033    2033 0  1,2110 0                TCR      chkCCS         
02034    2034 0  1,2244 1                TCR      chkINDEX       
02035    2035 0  1,2274 1                TCR      chkXCH         
02036    2036 0  1,2400 1                TCR      chkCS          
02037    2037 0  1,2446 0                TCR      chkTS          
02040    2040 0  1,2573 1                TCR      chkAD          
02041    2041 0  1,2674 0                TCR      chkMASK        
                          
                          ; Passed all tests.
02042    2042 0  1,2714 1                TCR      finish         
                          
                          fail           EQU      *              
02043    2043 3  0,0100 0                XCH      curtest        ; load last passed test into A
02044    2044 5  0,0100 0                TS       curtest        
                          
                          end            EQU      *              
02045    2045 0  1,2045 1                TC       end            ; finished, TC trap
                          
                          ; ----------------------------------------------
                          ; INITIALIZE FOR START OF TESTING
                          
02046    2046     00000 1 STRTcode       DS       START          
                          
                          begin          EQU      *              
02047    2047 3  1,2046 1                XCH      STRTcode       
02050    2050 5  0,0100 0                TS       curtest        ; set current test code to START
02051    2051 0  0,0000 0                RETURN                  
                          
                          ; ----------------------------------------------
                          ; TEST TC INSTRUCTION SUBROUTINE
                          ; L:	TC	K
                          ; Verifies the following:
                          ; - Set C(Q) = TC L+1
                          ; - Take next instruction from K, and proceed from there.
                          
02052    2052     00001 0 TCcode         DS       TCtst          ; code for this test
02053    2053     02061 1 Qtest          DS       TCret1         ; expected return address
                          
                          chkTC          EQU      *              
02054    2054 3  0,0001 0                XCH      Q              
02055    2055 5  0,0101 1                TS       savQ           ; save return address
                          
02056    2056 3  1,2052 1                CAF      TCcode         
02057    2057 5  0,0100 0                TS       curtest        ; set current test code to this test
                          
                          ; attempt a jump
02060    2060 0  1,2062 1                TC       *+2            ; make test jump
02061    2061 0  1,2043 1 TCret1         TC       fail           ; failed to jump
                          
                          ; verify correct return address in Q
02062    2062 4  0,0001 1                CS       Q              
02063    2063 6  1,2053 0                AD       Qtest          ; put (-Q) + val2 in A
02064    2064 1  0,0000 0                CCS      A              ; A = DABS
02065    2065 0  1,2043 1                TC       fail           ; >0 (Q < Qtest)
02066    2066 0  1,2043 1                TC       fail           ; +0 (never happens)
02067    2067 0  1,2043 1                TC       fail           ; <0 (Q > Qtest)
                          
                          ; passed the test
02070    2070 3  0,0101 1                XCH      savQ           
02071    2071 5  0,0001 0                TS       Q              ; restore return address
02072    2072 0  0,0000 0                RETURN                  
                          ; ----------------------------------------------
                          ; TEST CCS INSTRUCTION SUBROUTINE
                          ; L:	CCS	K
                          ; Verifies the following:
                          ; - take next instruction from L+n and proceed from there, where:
                          ; -- n = 1 if C(K) > 0
                          ; -- n = 2 if C(K) = +0
                          ; -- n = 3 if C(K) < 0
                          ; -- n = 4 if C(K) = -0
                          ; - set C(A) = DABS[C(K)], where DABS (diminished abs value):
                          ; -- DABS(a) = abs(a) - 1,	if abs(a) > 1
                          ; -- DABS(a) = +0, 		if abs(a) <= 1
                          
02073    2073     00002 0 CCScode        DS       CCStst         ; code for this test
                          ; test values (K)
02074    2074     77775 1 CCSkM2         DS       -2             
02075    2075     77776 1 CCSkM1         DS       -1             
02076    2076     77777 0 CCSkM0         DS       -0             
02077    2077     00000 1 CCSkP0         DS       +0             
02100    2100     00001 0 CCSkP1         DS       +1             
02101    2101     00002 0 CCSkP2         DS       +2             
                          
                          ; expected DABS values
02102    2102     00001 0 CCSdM2         DS       1              ; for K=-2, DABS = +1
02103    2103     00000 1 CCSdM1         DS       0              ; for K=-1, DABS = +0
02104    2104     00000 1 CCSdM0         DS       0              ; for K=-0, DABS = +0
02105    2105     00000 1 CCSdP0         DS       0              ; for K=+0, DABS = +0
02106    2106     00000 1 CCSdP1         DS       0              ; for K=+1, DABS = +0
02107    2107     00001 0 CCSdP2         DS       1              ; for K=+2, DABS = +1
                          
                          chkCCS         EQU      *              
02110    2110 3  0,0001 0                XCH      Q              
02111    2111 5  0,0101 1                TS       savQ           ; save return address
                          
02112    2112 3  1,2073 1                CAF      CCScode        
02113    2113 5  0,0100 0                TS       curtest        ; set current test code to this test
                          
                          ; set K to -2 and execute CCS: 
                          ; check for correct branch
02114    2114 3  1,2074 0                CAF      CCSkM2         ; set K = -2
02115    2115 5  0,0102 1                TS       CCSk           
02116    2116 1  0,0102 0                CCS      CCSk           ; A = DABS[C(K)]
02117    2117 0  1,2043 1                TC       fail           ; K > 0
02120    2120 0  1,2043 1                TC       fail           ; K= +0
02121    2121 0  1,2123 0                TC       *+2            ; K < 0
02122    2122 0  1,2043 1                TC       fail           ; K= -0
                          ; check for correct DABS in A (for K=-2, it should be 1)
02123    2123 4  0,0000 0                COM                     ; 1's compliment of A
02124    2124 6  1,2102 0                AD       CCSdM2         ; put (-A) + expected value in A
02125    2125 1  0,0000 0                CCS      A              ; A = DABS
02126    2126 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02127    2127 0  1,2043 1                TC       fail           ; +0
02130    2130 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; set K to -1 and execute CCS: 
                          ; check for correct branch
02131    2131 3  1,2075 1                CAF      CCSkM1         ; set K = -1
02132    2132 5  0,0102 1                TS       CCSk           
02133    2133 1  0,0102 0                CCS      CCSk           ; A = DABS[C(K)]
02134    2134 0  1,2043 1                TC       fail           ; K > 0
02135    2135 0  1,2043 1                TC       fail           ; K= +0
02136    2136 0  1,2140 0                TC       *+2            ; K < 0
02137    2137 0  1,2043 1                TC       fail           ; K= -0
                          ; check for correct DABS in A (for K=-1, it should be +0)
02140    2140 4  0,0000 0                COM                     ; 1's compliment of A
02141    2141 6  1,2103 1                AD       CCSdM1         ; put (-A) + expected value in A
02142    2142 1  0,0000 0                CCS      A              ; A = DABS
02143    2143 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02144    2144 0  1,2043 1                TC       fail           ; +0
02145    2145 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; set K to -0 and execute CCS: 
                          ; check for correct branch
02146    2146 3  1,2076 1                CAF      CCSkM0         ; set K = -0
02147    2147 5  0,0102 1                TS       CCSk           
02150    2150 1  0,0102 0                CCS      CCSk           ; A = DABS[C(K)]
02151    2151 0  1,2043 1                TC       fail           ; K > 0
02152    2152 0  1,2043 1                TC       fail           ; K= +0
02153    2153 0  1,2043 1                TC       fail           ; K < 0
                          ; check for correct DABS in A (for K=-0, it should be +0)
02154    2154 4  0,0000 0                COM                     ; 1's compliment of A
02155    2155 6  1,2104 0                AD       CCSdM0         ; put (-A) + expected value in A
02156    2156 1  0,0000 0                CCS      A              ; A = DABS
02157    2157 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02160    2160 0  1,2043 1                TC       fail           ; +0
02161    2161 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; set K to +0 and execute CCS: 
                          ; check for correct branch
02162    2162 3  1,2077 0                CAF      CCSkP0         ; set K = +0
02163    2163 5  0,0102 1                TS       CCSk           
02164    2164 1  0,0102 0                CCS      CCSk           ; A = DABS[C(K)]
02165    2165 0  1,2043 1                TC       fail           ; K > 0
02166    2166 0  1,2171 1                TC       *+3            ; K= +0
02167    2167 0  1,2043 1                TC       fail           ; K < 0
02170    2170 0  1,2043 1                TC       fail           ; K= -0
                          ; check for correct DABS in A (for K=+0, it should be +0)
02171    2171 4  0,0000 0                COM                     ; 1's compliment of A
02172    2172 6  1,2105 1                AD       CCSdP0         ; put (-A) + expected value in A
02173    2173 1  0,0000 0                CCS      A              ; A = DABS
02174    2174 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02175    2175 0  1,2043 1                TC       fail           ; +0
02176    2176 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; set K to +1 and execute CCS: 
                          ; check for correct branch
02177    2177 3  1,2100 1                CAF      CCSkP1         ; set K = +1
02200    2200 5  0,0102 1                TS       CCSk           
02201    2201 1  0,0102 0                CCS      CCSk           ; A = DABS[C(K)]
02202    2202 0  1,2206 1                TC       *+4            ; K > 0
02203    2203 0  1,2043 1                TC       fail           ; K= +0
02204    2204 0  1,2043 1                TC       fail           ; K < 0
02205    2205 0  1,2043 1                TC       fail           ; K= -0
                          ; check for correct DABS in A (for K=+1, it should be +0)
02206    2206 4  0,0000 0                COM                     ; 1's compliment of A
02207    2207 6  1,2106 1                AD       CCSdP1         ; put (-A) + expected value in A
02210    2210 1  0,0000 0                CCS      A              ; A = DABS
02211    2211 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02212    2212 0  1,2043 1                TC       fail           ; +0
02213    2213 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; set K to +2 and execute CCS: 
                          ; check for correct branch
02214    2214 3  1,2101 0                CAF      CCSkP2         ; set K = +2
02215    2215 5  0,0102 1                TS       CCSk           
02216    2216 1  0,0102 0                CCS      CCSk           ; A = DABS[C(K)]
02217    2217 0  1,2223 0                TC       *+4            ; K > 0
02220    2220 0  1,2043 1                TC       fail           ; K= +0
02221    2221 0  1,2043 1                TC       fail           ; K < 0
02222    2222 0  1,2043 1                TC       fail           ; K= -0
                          ; check for correct DABS in A (for K=+2, it should be +1)
02223    2223 4  0,0000 0                COM                     ; 1's compliment of A
02224    2224 6  1,2107 0                AD       CCSdP2         ; put (-A) + expected value in A
02225    2225 1  0,0000 0                CCS      A              ; A = DABS
02226    2226 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02227    2227 0  1,2043 1                TC       fail           ; +0
02230    2230 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; passed the test
02231    2231 3  0,0101 1                XCH      savQ           
02232    2232 5  0,0001 0                TS       Q              ; restore return address
02233    2233 0  0,0000 0                RETURN                  
                          ; ----------------------------------------------
                          ; TEST INDEX INSTRUCTION SUBROUTINE
                          ; L:	INDEX	K	(where K != 0025)
                          ; Verifies the following;
                          ; - Use the sum of C(L+1) + C(K) as the next instruction
                          ; -- just as if that sum had been taken from L+1.
                          
02234    2234     00003 1 INDXcode       DS       INDEXtst       ; code for this test
02235    2235     00005 1 INDXst         DS       5              ; somewhere in fixed memory
                          
02236    2236     00000 1 INDXbas        DS       0              ; base address for indexing
02237    2237     00001 0                DS       1              
02240    2240     00002 0                DS       2              
02241    2241     00003 1                DS       3              
02242    2242     00004 0                DS       4              
02243    2243     00005 1                DS       5              
                          
                          chkINDEX       EQU      *              
02244    2244 3  0,0001 0                XCH      Q              
02245    2245 5  0,0101 1                TS       savQ           ; save return address
                          
02246    2246 3  1,2234 0                CAF      INDXcode       
02247    2247 5  0,0100 0                TS       curtest        ; set current test code to this test
                          
                          ; Decrementing loop
                          ;	- always executes at least once (tests at end of loop)
                          ;	- loops 'INDXst+1' times; decrements INDXval
                          
02250    2250 3  1,2235 1                XCH      INDXst         ; initialize loop counter
                          
                          INDXlop        EQU      *              
02251    2251 5  0,0103 0                TS       INDXval        
                          
                          ; perform indexed CAF of values in INDXbas array;
                          ; index values range from 5 to 0
02252    2252 2  0,0103 1                INDEX    INDXval        
02253    2253 3  1,2236 1                CAF      INDXbas        
                          
                          ; verify value retrieved using INDEX matches expected value
02254    2254 4  0,0000 0                COM                     ; get -A
02255    2255 6  0,0103 0                AD       INDXval        ; put (-A) + expected value in A
02256    2256 1  0,0000 0                CCS      A              ; compare
02257    2257 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02260    2260 0  1,2043 1                TC       fail           ; +0
02261    2261 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
02262    2262 1  0,0103 1                CCS      INDXval        ; done?
02263    2263 0  1,2251 0                TC       INDXlop        ; not yet
                          
02264    2264 3  0,0101 1                XCH      savQ           
02265    2265 5  0,0001 0                TS       Q              ; restore return address
02266    2266 0  0,0000 0                RETURN                  
                          ; ----------------------------------------------
                          ; TEST XCH INSTRUCTION SUBROUTINE
                          ; L:	XCH	K
                          ; Verifies the following:
                          ; - set C(A) = b(K)
                          ; - set C(K) = b(A)
                          ; - take next instruction from L+1
                          
02267    2267     00004 0 XCHcode        DS       XCHtst         ; code for this test
                          ; XCH test values
02270    2270     00000 1 XCHfP0         DS       +0             
02271    2271     77777 0 XCHfM0         DS       -0             
02272    2272     52525 1 XCHfalt1       DS       %52525         ; alternating bit pattern 1
02273    2273     25252 0 XCHfalt2       DS       %25252         ; alternating bit pattern 2
                          
                          chkXCH         EQU      *              
02274    2274 3  0,0001 0                XCH      Q              
02275    2275 5  0,0101 1                TS       savQ           ; save return address
                          
02276    2276 3  1,2267 0                CAF      XCHcode        
02277    2277 5  0,0100 0                TS       curtest        ; set current test code to this test
                          
                          ; test - initial conditions: K=+0, A=-0
                          ; initialize A
02300    2300 4  1,2270 1                CS       XCHfP0         
                          ; exchange A and K
02301    2301 3  0,0104 1                XCH      XCHkP0         
                          ; test contents of A for expected value
02302    2302 4  0,0000 0                COM                     ; get -A
02303    2303 6  1,2270 0                AD       XCHfP0         ; put (-A) + expected value in A
02304    2304 1  0,0000 0                CCS      A              ; A = DABS
02305    2305 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02306    2306 0  1,2043 1                TC       fail           ; +0
02307    2307 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          ; test contents of K for expected value
02310    2310 4  0,0104 0                CS       XCHkP0         ; get -A
02311    2311 6  1,2271 1                AD       XCHfM0         ; put (-A) + expected value in A
02312    2312 1  0,0000 0                CCS      A              ; A = DABS
02313    2313 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02314    2314 0  1,2043 1                TC       fail           ; +0
02315    2315 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; test - initial conditions: K=-0, A=+0
                          ; initialize A
02316    2316 4  1,2271 0                CS       XCHfM0         
                          ; exchange A and K
02317    2317 3  0,0105 0                XCH      XCHkM0         
                          ; test contents of A for expected value
02320    2320 4  0,0000 0                COM                     ; get -A
02321    2321 6  1,2271 1                AD       XCHfM0         ; put (-A) + expected value in A
02322    2322 1  0,0000 0                CCS      A              ; A = DABS
02323    2323 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02324    2324 0  1,2043 1                TC       fail           ; +0
02325    2325 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          ; test contents of K for expected value
02326    2326 4  0,0105 1                CS       XCHkM0         ; get -A
02327    2327 6  1,2270 0                AD       XCHfP0         ; put (-A) + expected value in A
02330    2330 1  0,0000 0                CCS      A              ; A = DABS
02331    2331 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02332    2332 0  1,2043 1                TC       fail           ; +0
02333    2333 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; test - initial conditions: K=52525, A=25252
                          ; initialize A
02334    2334 4  1,2272 0                CS       XCHfalt1       
                          ; exchange A and K
02335    2335 3  0,0106 0                XCH      XCHkalt1       
                          ; test contents of A for expected value
02336    2336 4  0,0000 0                COM                     ; get -A
02337    2337 6  1,2272 1                AD       XCHfalt1       ; put (-A) + expected value in A
02340    2340 1  0,0000 0                CCS      A              ; A = DABS
02341    2341 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02342    2342 0  1,2043 1                TC       fail           ; +0
02343    2343 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          ; test contents of K for expected value
02344    2344 4  0,0106 1                CS       XCHkalt1       ; get -A
02345    2345 6  1,2273 0                AD       XCHfalt2       ; put (-A) + expected value in A
02346    2346 1  0,0000 0                CCS      A              ; A = DABS
02347    2347 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02350    2350 0  1,2043 1                TC       fail           ; +0
02351    2351 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; test - initial conditions: K=25252, A=52525
                          ; initialize A
02352    2352 4  1,2273 1                CS       XCHfalt2       
                          ; exchange A and K
02353    2353 3  0,0107 1                XCH      XCHkalt2       
                          ; test contents of A for expected value
02354    2354 4  0,0000 0                COM                     ; get -A
02355    2355 6  1,2273 0                AD       XCHfalt2       ; put (-A) + expected value in A
02356    2356 1  0,0000 0                CCS      A              ; A = DABS
02357    2357 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02360    2360 0  1,2043 1                TC       fail           ; +0
02361    2361 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          ; test contents of K for expected value
02362    2362 4  0,0107 0                CS       XCHkalt2       ; get -A
02363    2363 6  1,2272 1                AD       XCHfalt1       ; put (-A) + expected value in A
02364    2364 1  0,0000 0                CCS      A              ; A = DABS
02365    2365 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02366    2366 0  1,2043 1                TC       fail           ; +0
02367    2367 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; passed the test
02370    2370 3  0,0101 1                XCH      savQ           
02371    2371 5  0,0001 0                TS       Q              ; restore return address
02372    2372 0  0,0000 0                RETURN                  
                          
                          ; ----------------------------------------------
                          ; TEST CS INSTRUCTION SUBROUTINE
                          ; L:	CS	K
                          ; Verifies the following:
                          ; - Set C(A) = -C(K)
                          ; - Take next instruction from L+1
                          
02373    2373     00005 1 CScode         DS       CStst          ; code for this test
                          ; test values (K)
02374    2374     00000 1 CSkP0          DS       +0             
02375    2375     77777 0 CSkM0          DS       -0             
02376    2376     52525 1 CSkalt1        DS       %52525         ; 1's C of CSkalt2
02377    2377     25252 0 CSkalt2        DS       %25252         ; 1's C of CSkalt1
                          
                          chkCS          EQU      *              
02400    2400 3  0,0001 0                XCH      Q              
02401    2401 5  0,0101 1                TS       savQ           ; save return address
                          
02402    2402 3  1,2373 1                CAF      CScode         
02403    2403 5  0,0100 0                TS       curtest        ; set current test code to this test
                          
                          ; clear and subtract +0
02404    2404 4  1,2374 1                CS       CSkP0          ; load 1's compliment of K into A
02405    2405 6  1,2374 0                AD       CSkP0          ; put (-A) + expected value in A
02406    2406 1  0,0000 0                CCS      A              ; compare
02407    2407 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02410    2410 0  1,2043 1                TC       fail           ; +0
02411    2411 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; clear and subtract -0
02412    2412 4  1,2375 0                CS       CSkM0          ; load 1's compliment of K into A
02413    2413 6  1,2375 1                AD       CSkM0          ; put (-A) + expected value in A
02414    2414 1  0,0000 0                CCS      A              ; compare
02415    2415 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02416    2416 0  1,2043 1                TC       fail           ; +0
02417    2417 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; clear and subtract alternating bit pattern %52525
02420    2420 4  1,2376 0                CS       CSkalt1        ; load 1's compliment of K into A
02421    2421 6  1,2376 1                AD       CSkalt1        ; put (-A) + expected value in A
02422    2422 1  0,0000 0                CCS      A              ; compare
02423    2423 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02424    2424 0  1,2043 1                TC       fail           ; +0
02425    2425 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; clear and subtract alternating bit pattern %25252
02426    2426 4  1,2377 1                CS       CSkalt2        ; load 1's compliment of K into A
02427    2427 6  1,2377 0                AD       CSkalt2        ; put (-A) + expected value in A
02430    2430 1  0,0000 0                CCS      A              ; compare
02431    2431 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02432    2432 0  1,2043 1                TC       fail           ; +0
02433    2433 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; passed the test
02434    2434 3  0,0101 1                XCH      savQ           
02435    2435 5  0,0001 0                TS       Q              ; restore return address
02436    2436 0  0,0000 0                RETURN                  
                          ; ----------------------------------------------
                          ; TEST TS INSTRUCTION SUBROUTINE
                          ; L;	TS 	K
                          ; Verifies the following:
                          ; - Set C(K) = b(A)
                          ; - If b(A) contains no overflow, 
                          ; -- C(A) = b(A); take next instruction from L+1
                          ; - If b(A) has positive overflow, C(A) = 000001; 
                          ; -- take next instruction from L+2
                          ; - If b(A) has negative overflow, C(A) = 177776; 
                          ; -- take next instruction from L+2
                          
02437    2437     00006 1 TScode         DS       TStst          ; code for this test
02440    2440     00001 0 TSone          DS       +1             
02441    2441     00000 1 TSzero         DS       +0             
02442    2442     77777 0 TSmzero        DS       -0             
02443    2443     77776 1 TSmone         DS       -1             
02444    2444     37777 1 TSkP1          DS       %37777         ; TEST1: largest positive number w/no overflow
02445    2445     40000 0 TSkM1          DS       %40000         ; TEST2: largest negative number w/no overflow
                          
                          chkTS          EQU      *              
02446    2446 3  0,0001 0                XCH      Q              
02447    2447 5  0,0101 1                TS       savQ           ; save return address
                          
02450    2450 3  1,2437 0                CAF      TScode         
02451    2451 5  0,0100 0                TS       curtest        ; set current test code to this test
                          
                          ; initialize TSk to -0
02452    2452 3  1,2442 1                CAF      TSmzero        
02453    2453 3  0,0110 1                XCH      TSk            
                          
                          ; TEST 1: store positive number, no overflow
02454    2454 3  1,2444 1                CAF      TSkP1          
02455    2455 5  0,0110 1                TS       TSk            
02456    2456 0  1,2460 1                TC       *+2            ; no overflow
02457    2457 0  1,2043 1                TC       fail           ; overflow
                          ; verify C(A) = b(A)
02460    2460 4  0,0000 0                COM                     ; get -A
02461    2461 6  1,2444 1                AD       TSkP1          ; put (-A) + expected value in A
02462    2462 1  0,0000 0                CCS      A              ; compare
02463    2463 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02464    2464 0  1,2043 1                TC       fail           ; +0
02465    2465 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          ; verify C(K) = b(A)
02466    2466 4  1,2444 0                CS       TSkP1          ; get -expected value
02467    2467 6  0,0110 1                AD       TSk            ; put (-expected value) + C(K) into A
02470    2470 1  0,0000 0                CCS      A              ; compare
02471    2471 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02472    2472 0  1,2043 1                TC       fail           ; +0
02473    2473 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; TEST 2: store negative number, no overflow
02474    2474 3  1,2445 0                CAF      TSkM1          
02475    2475 5  0,0110 1                TS       TSk            
02476    2476 0  1,2500 0                TC       *+2            ; no overflow
02477    2477 0  1,2043 1                TC       fail           ; overflow
                          ; verify C(A) = b(A)
02500    2500 4  0,0000 0                COM                     ; get -A
02501    2501 6  1,2445 0                AD       TSkM1          ; put (-A) + expected value in A
02502    2502 1  0,0000 0                CCS      A              ; compare
02503    2503 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02504    2504 0  1,2043 1                TC       fail           ; +0
02505    2505 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          ; verify C(K) = b(A)
02506    2506 4  1,2445 1                CS       TSkM1          ; get -expected value
02507    2507 6  0,0110 1                AD       TSk            ; put (-expected value) + C(K) into A
02510    2510 1  0,0000 0                CCS      A              ; compare
02511    2511 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02512    2512 0  1,2043 1                TC       fail           ; +0
02513    2513 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; TEST 3: store positive number, overflow
02514    2514 3  1,2444 1                CAF      TSkP1          ; get largest positive number
02515    2515 6  1,2440 0                AD       TSone          ; make it overflow; A = negative overflow
02516    2516 5  0,0110 1                TS       TSk            ; store the positive overflow
02517    2517 0  1,2043 1                TC       fail           ; no overflow
                          ; verify C(A) = 000001
02520    2520 4  0,0000 0                COM                     ; get -A
02521    2521 6  1,2440 0                AD       TSone          ; put (-A) + expected value in A
02522    2522 1  0,0000 0                CCS      A              ; compare
02523    2523 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02524    2524 0  1,2043 1                TC       fail           ; +0
02525    2525 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          ; verify C(K) = positive overflow
02526    2526 4  1,2441 0                CS       TSzero         ; get -expected value
02527    2527 6  0,0110 1                AD       TSk            ; put (-expected value) + C(K) into A
02530    2530 1  0,0000 0                CCS      A              ; compare
02531    2531 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02532    2532 0  1,2043 1                TC       fail           ; +0
02533    2533 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; TEST 4: store negative number, overflow
02534    2534 3  1,2445 0                CAF      TSkM1          ; get largest negative number
02535    2535 6  1,2443 0                AD       TSmone         ; make it overflow; A = negative overflow
02536    2536 5  0,0110 1                TS       TSk            ; store the negative overflow
02537    2537 0  1,2043 1                TC       fail           ; no overflow
                          ; verify C(A) = 177776
02540    2540 4  0,0000 0                COM                     ; get -A
02541    2541 6  1,2443 0                AD       TSmone         ; put (-A) + expected value in A
02542    2542 1  0,0000 0                CCS      A              ; compare
02543    2543 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02544    2544 0  1,2043 1                TC       fail           ; +0
02545    2545 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          ; verify C(K) = negative overflow
02546    2546 4  1,2442 0                CS       TSmzero        ; get -expected value
02547    2547 6  0,0110 1                AD       TSk            ; put (-expected value) + C(K) into A
02550    2550 1  0,0000 0                CCS      A              ; compare
02551    2551 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02552    2552 0  1,2043 1                TC       fail           ; +0
02553    2553 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
02554    2554 3  0,0101 1                XCH      savQ           
02555    2555 5  0,0001 0                TS       Q              ; restore return address
02556    2556 0  0,0000 0                RETURN                  
                          ; ----------------------------------------------
                          ; TEST AD INSTRUCTION SUBROUTINE
                          ; L:	AD	K
                          ; Verifies the following:
                          ; - Set C(A) = b(A) + C(K)
                          ; - Take next instruction from L+1
                          ; - if C(A) has positive overflow,
                          ; -- increment overflow counter by 1
                          ; - if C(A) has negative overflow,
                          ; -- decrement overflow counter by 1
                          
02557    2557     00007 0 ADcode         DS       ADtst          ; code for this test
02560    2560     00000 1 ADplus0        DS       +0             
02561    2561     00001 0 ADplus1        DS       1              
02562    2562     77776 1 ADmin1         DS       -1             
                          
02563    2563     25252 0 AD25252        DS       %25252         ; +10922 decimal
02564    2564     12525 0 AD12525        DS       %12525         ; +5461 decimal
02565    2565     37777 1 AD37777        DS       %37777         ; largest positive number
02566    2566     12524 1 AD12524        DS       %12524         ; positive overflow of %25252+%25252
                          
02567    2567     52525 1 AD52525        DS       %52525         ; -10922 decimal
02570    2570     65252 1 AD65252        DS       %65252         ; -5461 decimal
02571    2571     40000 0 AD40000        DS       %40000         ; largest negative number
02572    2572     65253 0 AD65253        DS       %65253         ; negative overflow of %52525+65252
                          
                          chkAD          EQU      *              
02573    2573 3  0,0001 0                XCH      Q              
02574    2574 5  0,0101 1                TS       savQ           ; save return address
                          
02575    2575 3  1,2557 1                CAF      ADcode         
02576    2576 5  0,0100 0                TS       curtest        ; set current test code to this test
                          
                          ; TEST1: sum positive, no overflow
                          ; add: %25252 + %12525 = %37777 (sign + 14 magnitude)
02577    2577 3  1,2563 0                CAF      AD25252        
02600    2600 6  1,2564 1                AD       AD12525        
                          ; verify C(A) = %37777
02601    2601 4  0,0000 0                COM                     ; get -A
02602    2602 6  1,2565 0                AD       AD37777        ; put (-A) + expected value in A
02603    2603 1  0,0000 0                CCS      A              ; compare
02604    2604 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02605    2605 0  1,2043 1                TC       fail           ; +0
02606    2606 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; TEST2: sum negative, no overflow (sign + 14 magnitude)
                          ; add: %52525 + %65252 = %40000
02607    2607 3  1,2567 1                CAF      AD52525        
02610    2610 6  1,2570 1                AD       AD65252        
                          ; verify C(A) = %40000
02611    2611 4  0,0000 0                COM                     ; get -A
02612    2612 6  1,2571 0                AD       AD40000        ; put (-A) + expected value in A
02613    2613 1  0,0000 0                CCS      A              ; compare
02614    2614 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02615    2615 0  1,2043 1                TC       fail           ; +0
02616    2616 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; TEST3: sum positive, overflow
                          ; initialize overflow counter and positive overflow storage
02617    2617 3  1,2560 0                CAF      ADplus0        
02620    2620 5  0,0034 0                TS       OVFCNTR        
02621    2621 5  0,0111 0                TS       ADk            
                          ; add: %25252 + %25252 = %52524 (sign + 14 magnitude)
02622    2622 3  1,2563 0                CAF      AD25252        
02623    2623 6  1,2563 0                AD       AD25252        
02624    2624 5  0,0111 0                TS       ADk            ; store positive overflow
02625    2625 0  1,2043 1                TC       fail           
                          ; verify ADk = %12524
02626    2626 4  0,0111 1                CS       ADk            ; get -A
02627    2627 6  1,2566 0                AD       AD12524        ; put (-A) + expected value in A
02630    2630 1  0,0000 0                CCS      A              ; compare
02631    2631 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02632    2632 0  1,2043 1                TC       fail           ; +0
02633    2633 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          ; verify overflow counter =%00001
02634    2634 4  0,0034 1                CS       OVFCNTR        ; get -A
02635    2635 6  1,2561 1                AD       ADplus1        ; put (-A) + expected value in A
02636    2636 1  0,0000 0                CCS      A              ; compare
02637    2637 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02640    2640 0  1,2043 1                TC       fail           ; +0
02641    2641 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
                          ; TEST4: sum negative, overflow
02642    2642 3  1,2560 0                CAF      ADplus0        
02643    2643 5  0,0034 0                TS       OVFCNTR        
02644    2644 5  0,0111 0                TS       ADk            
                          ; add: %52525 + %52525 = %25253 (sign + 14 magnitude)
02645    2645 3  1,2567 1                CAF      AD52525        
02646    2646 6  1,2567 1                AD       AD52525        
02647    2647 5  0,0111 0                TS       ADk            ; store negative overflow
02650    2650 0  1,2043 1                TC       fail           
                          ; verify ADk = %65253
02651    2651 4  0,0111 1                CS       ADk            ; get -A
02652    2652 6  1,2572 0                AD       AD65253        ; put (-A) + expected value in A
02653    2653 1  0,0000 0                CCS      A              ; compare
02654    2654 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02655    2655 0  1,2043 1                TC       fail           ; +0
02656    2656 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          ; verify overflow counter =%77776
02657    2657 4  0,0034 1                CS       OVFCNTR        ; get -A
02660    2660 6  1,2562 1                AD       ADmin1         ; put (-A) + expected value in A
02661    2661 1  0,0000 0                CCS      A              ; compare
02662    2662 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02663    2663 0  1,2043 1                TC       fail           ; +0
02664    2664 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
02665    2665 3  0,0101 1                XCH      savQ           
02666    2666 5  0,0001 0                TS       Q              ; restore return address
02667    2667 0  0,0000 0                RETURN                  
                          ; ----------------------------------------------
                          ; TEST MASK INSTRUCTION SUBROUTINE
                          ; L:	MASK	K
                          ; Verifies the following:
                          ; - Set C(A) = b(A) & C(K)
                          
02670    2670     00010 0 MASKcode       DS       MASKtst        ; code for this test
02671    2671     46314 0 MASK1          DS       %46314         
02672    2672     25252 0 MASK2          DS       %25252         
02673    2673     04210 0 MASKval        DS       %04210         ; expected result of MASK1 & MASK2
                          
                          chkMASK        EQU      *              
02674    2674 3  0,0001 0                XCH      Q              
02675    2675 5  0,0101 1                TS       savQ           ; save return address
                          
                          ; perform logical and of MASK1 and MASK2
02676    2676 3  1,2671 0                CAF      MASK1          
02677    2677 7  1,2672 1                MASK     MASK2          
                          ; verify C(A) = b(A) & C(K)
02700    2700 4  0,0000 0                COM                     ; get -A
02701    2701 6  1,2673 1                AD       MASKval        ; put (-A) + expected value in A
02702    2702 1  0,0000 0                CCS      A              ; compare
02703    2703 0  1,2043 1                TC       fail           ; >0 (A < expected value)
02704    2704 0  1,2043 1                TC       fail           ; +0
02705    2705 0  1,2043 1                TC       fail           ; <0 (A > expected value)
                          
02706    2706 3  1,2670 1                CAF      MASKcode       
02707    2707 5  0,0100 0                TS       curtest        ; set current test code to this test
                          
                          ; passed the test
02710    2710 3  0,0101 1                XCH      savQ           
02711    2711 5  0,0001 0                TS       Q              ; restore return address
02712    2712 0  0,0000 0                RETURN                  
                          ; ----------------------------------------------
                          ; PASSED ALL TESTS!
                          
02713    2713     12345 0 PASScode       DS       PASS           
                          
                          finish         EQU      *              
02714    2714 3  1,2713 0                CAF      PASScode       
02715    2715 5  0,0100 0                TS       curtest        ; set current test code to PASS
02716    2716 0  0,0000 0                RETURN                  
                          
                          ; ----------------------------------------------
                          ; INTERRUPT SERVICE ROUTINE
                          
                          goT3           EQU      *              
                          goER           EQU      *              
                          goDS           EQU      *              
                          goKEY          EQU      *              
                          goUP           EQU      *              
                          
                          
                          endRUPT        EQU      *              
02717    2717 3  0,0027 1                XCH      QRUPT          ; restore Q
02720    2720 5  0,0001 0                TS       Q              
02721    2721 3  0,0026 0                XCH      ARUPT          ; restore A
02722    2722 2  0,0000 1                RESUME                  ; finished, go back
                          
                          
                          

Assembly complete. Errors = 0

Symbol table:
START          000000   TCtst          000001   CCStst         000002   
INDEXtst       000003   XCHtst         000004   CStst          000005   
TStst          000006   ADtst          000007   MASKtst        000010   
PASS           012345   EXTENDER       005777   OVFCNTR        000034   
curtest        000100   savQ           000101   CCSk           000102   
INDXval        000103   XCHkP0         000104   XCHkM0         000105   
XCHkalt1       000106   XCHkalt2       000107   TSk            000110   
ADk            000111   GOPROG         002000   T3RUPT         002004   
ERRUPT         002010   DSRUPT         002014   KEYRUPT        002020   
UPRUPT         002024   goMAIN         002030   fail           002043   
end            002045   STRTcode       002046   begin          002047   
TCcode         002052   Qtest          002053   chkTC          002054   
TCret1         002061   CCScode        002073   CCSkM2         002074   
CCSkM1         002075   CCSkM0         002076   CCSkP0         002077   
CCSkP1         002100   CCSkP2         002101   CCSdM2         002102   
CCSdM1         002103   CCSdM0         002104   CCSdP0         002105   
CCSdP1         002106   CCSdP2         002107   chkCCS         002110   
INDXcode       002234   INDXst         002235   INDXbas        002236   
chkINDEX       002244   INDXlop        002251   XCHcode        002267   
XCHfP0         002270   XCHfM0         002271   XCHfalt1       002272   
XCHfalt2       002273   chkXCH         002274   CScode         002373   
CSkP0          002374   CSkM0          002375   CSkalt1        002376   
CSkalt2        002377   chkCS          002400   TScode         002437   
TSone          002440   TSzero         002441   TSmzero        002442   
TSmone         002443   TSkP1          002444   TSkM1          002445   
chkTS          002446   ADcode         002557   ADplus0        002560   
ADplus1        002561   ADmin1         002562   AD25252        002563   
AD12525        002564   AD37777        002565   AD12524        002566   
AD52525        002567   AD65252        002570   AD40000        002571   
AD65253        002572   chkAD          002573   MASKcode       002670   
MASK1          002671   MASK2          002672   MASKval        002673   
chkMASK        002674   PASScode       002713   finish         002714   
goT3           002717   goER           002717   goDS           002717   
goKEY          002717   goUP           002717   endRUPT        002717   
ARUPT          000026   Q              000001   QRUPT          000027   
A              000000   